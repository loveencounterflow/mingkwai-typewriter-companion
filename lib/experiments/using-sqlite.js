// Generated by CoffeeScript 2.4.1
(function() {
  'use strict';
  var $, $async, CND, Database, PATH, PD, as_int, assign, badge, db, db_path, debug, echo, error, help, i, info, jr, len, mode, pipeline, q, r, ref, row, rpr, select, source, sql, sqlitemk_path, sqls, statement, urge, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'IME/EXPERIMENTS/KB';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  PATH = require('path');

  PD = require('pipedreams');

  ({$, $async, select} = PD);

  ({assign, jr} = CND);

  // db_path   = PATH.resolve PATH.join __dirname, '../../db/data.db'
  Database = require('better-sqlite3');

  sqlitemk_path = PATH.resolve(PATH.join(__dirname, '../../../../sqlite-for-mingkwai-ime'));

  db_path = PATH.join(sqlitemk_path, 'experiments/demo-amatch.db');

  db = new Database(db_path, {
    verbose: urge
  });

  db.loadExtension(PATH.join(sqlitemk_path, 'extensions/amatch.so'));

  source = PD.new_push_source();

  pipeline = [];

  pipeline.push(source);

  pipeline.push(PD.$show());

  pipeline.push(PD.$drain());

  PD.pull(...pipeline);

  as_int = function(x) {
    if (x) {
      return 1;
    } else {
      return 0;
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  db.function('matches', {
    deterministic: true
  }, function(text, pattern) {
    return as_int((text.match(new RegExp(pattern))) != null);
  });

  //-----------------------------------------------------------------------------------------------------------
  db.function('regexp_replace', {
    deterministic: true
  }, function(text, pattern, replacement) {
    return text.replace(new RegExp(pattern, 'g'), replacement);
  });

  //-----------------------------------------------------------------------------------------------------------
  db.function('cleanup_texname', {
    deterministic: true
  }, function(text) {
    var R;
    R = text;
    R = R.replace(/\\/g, '');
    R = R.replace(/[{}]/g, '-');
    R = R.replace(/-+/g, '-');
    R = R.replace(/^-/g, '');
    R = R.replace(/-$/g, '');
    R = R.replace(/'/g, 'acute');
    return R;
  });

  r = function(strings) {
    return ['run', strings.join('')];
  };

  q = function(strings) {
    return ['query', strings.join('')];
  };

  sqls = [
    // q""".tables"""
    r`drop view if exists xxx;`,
    q`select * from amatch_vtable\nwhere true\n  and ( distance <= 100 )\n  -- and ( word match 'abc' )\n  -- and ( word match 'xxxx' )\n  -- and ( word match 'cat' )\n  -- and ( word match 'dog' )\n  -- and ( word match 'television' )\n  -- and ( word match 'treetop' )\n  -- and ( word match 'bath' )\n  -- and ( word match 'kat' )\n  and ( word match 'laern' )\n  -- and ( word match 'wheather' )\n  -- and ( word match 'waether' )\n  ;`,
    // r"""create view xxx as select
    //     "UNICODE DESCRIPTION"     as uname,
    //     latex                     as latex,
    //     cleanup_texname( latex )  as texname
    //   from unicode_entities
    //   where true
    //     and ( not matches( latex, '^\\s*$' ) );"""
    // q"""select * from xxx limit 2500;"""
    q`select sqlite_version();`
  ];

  for (i = 0, len = sqls.length; i < len; i++) {
    [mode, sql] = sqls[i];
    urge(sql);
    try {
      statement = db.prepare(sql);
    } catch (error1) {
      error = error1;
      whisper('-'.repeat(108));
      warn("when trying to prepare statement");
      info(sql);
      warn("an error occurred:");
      info(error.message);
      whisper('-'.repeat(108));
      throw error;
    }
    switch (mode) {
      case 'run':
        debug(statement.run());
        break;
      case 'query':
        ref = statement.iterate();
        for (row of ref) {
          source.send(row);
        }
        break;
      default:
        throw new Error(`Âµ09202 unknown mode ${rpr(mode)}`);
    }
  }

}).call(this);

//# sourceMappingURL=using-sqlite.js.map
